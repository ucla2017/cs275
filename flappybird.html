<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - cube refraction [balls]</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#777;
				padding:0;
				margin:0;
				font-weight: bold;
				overflow:hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				color: #ffffff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				z-index:1000;
			}

			a {
				color: #ffffff;
			}

			#footer { width: 100%; margin: 2em auto; text-align: center; position: absolute; bottom: 0 }
			strong { color: red }

			#oldie a { color:#da0 }
		</style>
	</head>

	<body>
		<!-- <div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl cube refraction demo. skybox by <a href="http://www.zfight.com/" target="_blank">Jochum Skoglund</a></div> -->

		<div id="footer">
			press <strong>f</strong> to flap wings
		</div>

		<div id="status"> status started...</div>

		<div id="log"> log started...</div>


		<script src="three.js/three.min.js"></script>

		<script src="js/Detector.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;

			var camera, scene, renderer;
			var cameraCube, sceneCube;

			var mesh, lightMesh, geometry;
			var spheres = [];

			var morphs = [];
			var clock = new THREE.Clock();
			var animRemainTime = 0;
			var animBeginTime = 650;

			var directionalLight, pointLight;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100000 );
				camera.position.z = 3200;

				cameraCube = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100000 );

				scene = new THREE.Scene();
				sceneCube = new THREE.Scene();

				radiusTop = 30;
				height = 100;
				segmentsRadius = 50;
				segmentsHeight = 50;
				radiusBottom = radiusTop;

				var geometry = new THREE.CylinderGeometry( radiusTop, radiusBottom, height, segmentsRadius, segmentsHeight);

				var path = "textures/cube/skybox/";
				var format = '.jpg';
				var urls = [
					path + 'px' + format, path + 'nx' + format,
					path + 'py' + format, path + 'ny' + format,
					path + 'pz' + format, path + 'nz' + format
				];

				var textureCube = THREE.ImageUtils.loadTextureCube( urls, new THREE.CubeRefractionMapping() );
				var material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube, refractionRatio: 0.95 } );

				for ( var i = 0; i < 500; i ++ ) {

					var mesh = new THREE.Mesh( geometry, material );

					mesh.position.x = Math.random() * 10000 - 5000;
					mesh.position.y = Math.random() * 10000 - 5000;
					mesh.position.z = Math.random() * 10000 - 5000;

					mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 3 + 1;

					scene.add( mesh );

					spheres.push( mesh );

				}

				// Skybox
				initSkybox(textureCube);
				

				// LIGHTS

				hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
				hemiLight.color.setHSL( 0.6, 1, 0.6 );
				hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
				hemiLight.position.set( 0, 500, 0 );
				scene.add( hemiLight );


				// MORPHS

				function addMorph( geometry, speed, duration, x, y, z ) {

					var material = new THREE.MeshLambertMaterial( { color: 0xffaa55, morphTargets: true, vertexColors: THREE.FaceColors } );

					var meshAnim = new THREE.MorphAnimMesh( geometry, material );

					meshAnim.speed = speed;
					meshAnim.duration = duration;
					meshAnim.time = 600 * Math.random();
					//meshAnim.time = 650;

					meshAnim.position.set( x, y, z );
					meshAnim.rotation.y = Math.PI/2;

					meshAnim.castShadow = true;
					meshAnim.receiveShadow = false;

					scene.add( meshAnim );

					morphs.push( meshAnim );

					renderer.initWebGLObjects( scene );

				}

				function morphColorsToFaceColors( geometry ) {

					if ( geometry.morphColors && geometry.morphColors.length ) {

						var colorMap = geometry.morphColors[ 0 ];

						for ( var i = 0; i < colorMap.colors.length; i ++ ) {

							geometry.faces[ i ].color = colorMap.colors[ i ];

						}

					}

				}

				var loader = new THREE.JSONLoader();

				var startX = 0;

				loader.load( "models/animated/parrot.js", function( geometry ) {

					morphColorsToFaceColors( geometry );
					//addMorph( geometry, 250, 500, 0, 0, 2000);
					//addMorph( geometry, 250, 500, 0 * 500, 500, -200 );
					//addMorph( geometry, 250, 500, startX - Math.random() * 500, 500, 200 );
					//addMorph( geometry, 250, 500, startX - Math.random() * 500, 500, 1000 );

					geometry.computeMorphNormals();

					var material = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0xffffff, shininess: 20, morphTargets: true, morphNormals: true, vertexColors: THREE.FaceColors, shading: THREE.FlatShading } );
					var meshAnim = new THREE.MorphAnimMesh( geometry, material );

					meshAnim.duration = 1000;
					meshAnim.time = animBeginTime;

					var s = 5.35;
					meshAnim.scale.set( s, s, s );
					meshAnim.position.set(0, 0, 2000);
					meshAnim.position.y = 15;
					meshAnim.rotation.y = -1;

					meshAnim.castShadow = true;
					meshAnim.receiveShadow = true;

					scene.add( meshAnim );
					morphs.push( meshAnim );

					
				} );

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;
				container.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener( 'keydown', onKeyDown, false );
			}

			function initSkybox(textureCube) {
				var shader = THREE.ShaderLib[ "cube" ];
				shader.uniforms[ "tCube" ].value = textureCube;

				var material = new THREE.ShaderMaterial( {

					fragmentShader: shader.fragmentShader,
					vertexShader: shader.vertexShader,
					uniforms: shader.uniforms,
					depthWrite: false,
					side: THREE.BackSide

				} ),

				mesh = new THREE.Mesh( new THREE.BoxGeometry( 100, 100, 100 ), material );
				sceneCube.add( mesh );
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2,
				windowHalfY = window.innerHeight / 2,

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				cameraCube.aspect = window.innerWidth / window.innerHeight;
				cameraCube.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove(event) {

				mouseX = ( event.clientX - windowHalfX ) * 10;
				mouseY = ( event.clientY - windowHalfY ) * 10;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				// var timer = 0.0001 * Date.now();

				// for ( var i = 0, il = spheres.length; i < il; i ++ ) {

				// 	var sphere = spheres[ i ];

				// 	sphere.position.x = 5000 * Math.cos( timer + i );
				// 	sphere.position.y = 5000 * Math.sin( timer + i * 1.1 );

				// }

				// animate bird
				var delta = clock.getDelta();
				var elapseTime = clock.getElapsedTime();

				if (animRemainTime > 0) {
	
					animRemainTime -= delta;

					for ( var i = 0; i < morphs.length; i ++ ) {

						morph = morphs[ i ];
						morph.updateAnimation( 1000 * delta );
						morph.position.x -= 2;
					}
				}

				// update camera
				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;

				camera.lookAt( scene.position );
				cameraCube.rotation.copy( camera.rotation );

				// update status and log text
				str = 'mouseX = ' + mouseX + ', mouseY = ' + mouseY + ', ';
				str += 'delta = ' + delta.toFixed(2) + ', ';
				str += 'ElapsedTime = ' + elapseTime.toFixed(2) + '<br>';
				setStatus(str);
				if (Math.round(elapseTime*10) % 10 == 0) {
					setLog('...');
				}

				renderer.render( sceneCube, cameraCube );
				renderer.render( scene, camera );

			}

			function flapWings() {
				if (animRemainTime <= 0) {

					animRemainTime = 1;

					for ( var i = 0; i < morphs.length; i ++ ) {

						morph = morphs[ i ];
						morph.time = animBeginTime;

					}
				}
			}

			function setBirdPosition(x, y, z) {
				for ( var i = 0; i < morphs.length; i ++ ) {

					morph = morphs[ i ];
					morph.position.set(x, y, z);

				}
			}


			function setStatus(text) {
				document.getElementById('status').innerHTML = text;
			}

			function setLog(text) {
				document.getElementById('log').innerHTML = text;
			}

			function onKeyDown ( event ) {

				switch ( event.keyCode ) {

					case 70: /*f*/

					flapWings();
					setLog('<strong>f</strong> key pressed');
					break;

					case 68: /*d*/

					//dirLight.visible = !dirLight.visible;
					break;

				}

			}

		</script>

	</body>
</html>
